;
; Copyright (c) 2020 Raspberry Pi (Trading) Ltd.
;
; SPDX-License-Identifier: BSD-3-Clause
;

; Side-set pin 0 is used for PWM output

.program ppm
.side_set 1 opt

begin:    
    pull           side 0 ; pull from FIFO to OSR
    mov y,osr      side 1 ; copy the value from fifo into Y and set side pin HIGH
countloop:
    jmp y-- countloop      ; Loop until Y hits 0, then pull a fresh PWM value from FIFO
    jmp begin      side 0  ; reset pin to LOW

;    pull noblock    side 0 ; Pull from FIFO to OSR if available, else copy X to OSR.
;    mov x, osr             ; Copy most-recently-pulled value back to scratch X
;    pull noblock    side 0 ; We pull several time to be sure to use only the last value being in fifo
;   mov x, osr             ; Copy most-recently-pulled value back to scratch X
;    pull noblock    side 0 ; 
;    mov x, osr             ; Copy most-recently-pulled value back to scratch X
;   pull noblock    side 0 ; 
;    mov x, osr             ; Copy most-recently-pulled value back to scratch X
;    mov y, isr             ; ISR contains PWM period. Y used as counter.
;countloop:
;    jmp x!=y noset         ; Set pin high if X == Y, keep the two paths length matched
;    jmp skip        side 1
;noset:
;    nop                    ; Single dummy cycle to keep the two paths the same length
;skip:
;    jmp y-- countloop      ; Loop until Y hits 0, then pull a fresh PWM value from FIFO

% c-sdk {
#include "hardware/clocks.h"

static inline void ppm_program_init(PIO pio, uint sm, uint offset, uint pin) {
   pio_gpio_init(pio, pin);
   pio_sm_set_consecutive_pindirs(pio, sm, pin, 1, true);
   pio_sm_config c = ppm_program_get_default_config(offset);
   sm_config_set_sideset_pins(&c, pin);
   float div = (float)clock_get_hz(clk_sys) / (1000000 * 3);
   sm_config_set_clkdiv(&c, div);
   pio_sm_init(pio, sm, offset, &c);  // sm is left disabled at the end
   pio_sm_set_enabled(pio, sm, true); // start the state machine
}
%}

